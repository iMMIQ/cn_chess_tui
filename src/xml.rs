//! XML conversion for PGN (Portable Game Notation)
//!
//! This module provides conversion between PGN format and XML format
//! for Chinese Chess games. The XML format follows Chinese Chess standards
//! with a <pgn> root element, tag elements, and move elements.
//!
//! Example XML output:
//! ```xml
//! <?xml version="1.0" encoding="UTF-8"?>
//! <pgn>
//!   <tags>
//!     <Event>World Championship</Event>
//!     <Red>Hu Ronghua</Red>
//!     <Black>Liu Dahua</Black>
//!     <Result>1-0</Result>
//!   </tags>
//!   <moves>
//!     <move>h2e2</move>
//!     <move>h9g7</move>
//!     <move>h3g3</move>
//!   </moves>
//! </pgn>
//! ```

use crate::pgn::{PgnGame, PgnGameResult};
use std::fs::File;
use std::io::Write;

/// Escape special XML characters in a string
///
/// Converts:
/// - & -> &amp;
/// - < -> &lt;
/// - > -> &gt;
/// - " -> &quot;
/// - ' -> &apos;
///
/// # Examples
/// ```
/// use cn_chess_tui::xml::escape_xml;
///
/// assert_eq!(escape_xml("a < b"), "a &lt; b");
/// assert_eq!(escape_xml("Tom & Jerry"), "Tom &amp; Jerry");
/// assert_eq!(escape_xml("\"Hello\""), "&quot;Hello&quot;");
/// ```
pub fn escape_xml(s: &str) -> String {
    let mut escaped = String::with_capacity(s.len());
    for c in s.chars() {
        match c {
            '&' => escaped.push_str("&amp;"),
            '<' => escaped.push_str("&lt;"),
            '>' => escaped.push_str("&gt;"),
            '"' => escaped.push_str("&quot;"),
            '\'' => escaped.push_str("&apos;"),
            _ => escaped.push(c),
        }
    }
    escaped
}

/// Unescape XML entities in a string
///
/// Converts XML entities back to their original characters:
/// - &amp; -> &
/// - &lt; -> <
/// - &gt; -> >
/// - &quot; -> "
/// - &apos; -> '
///
/// # Examples
/// ```
/// use cn_chess_tui::xml::unescape_xml;
///
/// assert_eq!(unescape_xml("a &lt; b"), "a < b");
/// assert_eq!(unescape_xml("Tom &amp; Jerry"), "Tom & Jerry");
/// ```
pub fn unescape_xml(s: &str) -> String {
    let mut unescaped = String::with_capacity(s.len());
    let mut chars = s.chars().peekable();

    while let Some(c) = chars.next() {
        if c == '&' {
            // Try to parse an entity
            let mut entity = String::new();
            while let Some(&next) = chars.peek() {
                if next == ';' {
                    chars.next(); // Consume the semicolon
                    break;
                }
                entity.push(next);
                chars.next();
            }

            match entity.as_str() {
                "amp" => unescaped.push('&'),
                "lt" => unescaped.push('<'),
                "gt" => unescaped.push('>'),
                "quot" => unescaped.push('"'),
                "apos" => unescaped.push('\''),
                _ => {
                    // Unknown entity, keep as-is
                    unescaped.push('&');
                    unescaped.push_str(&entity);
                    if entity.is_empty() {
                        unescaped.push(';');
                    }
                }
            }
        } else {
            unescaped.push(c);
        }
    }

    unescaped
}

/// Convert a PgnGame to XML string format
///
/// # Examples
/// ```
/// use cn_chess_tui::pgn::{PgnGame, PgnGameResult};
/// use cn_chess_tui::xml::pgn_to_xml;
///
/// let mut game = PgnGame::new();
/// game.set_tag("Event", "Test Game");
/// game.set_tag("Red", "Player1");
/// game.add_move("h2e2");
/// game.add_move("h9g7");
/// game.result = PgnGameResult::RedWins;
///
/// let xml = pgn_to_xml(&game);
/// assert!(xml.contains("<Event>Test Game</Event>"));
/// assert!(xml.contains("<move>h2e2</move>"));
/// assert!(xml.contains("<move>h9g7</move>"));
/// ```
pub fn pgn_to_xml(game: &PgnGame) -> String {
    let mut xml = String::from(r#"<?xml version="1.0" encoding="UTF-8"?>"#);
    xml.push_str("\n<pgn>\n");

    // Tags section
    xml.push_str("  <tags>\n");
    for tag in &game.tags {
        let escaped_key = escape_xml(&tag.key);
        let escaped_value = escape_xml(&tag.value);
        xml.push_str(&format!(
            "    <{}>{}</{}>\n",
            escaped_key, escaped_value, escaped_key
        ));
    }
    xml.push_str("  </tags>\n");

    // Moves section
    if !game.moves.is_empty() {
        xml.push_str("  <moves>\n");
        for mv in &game.moves {
            let escaped_notation = escape_xml(&mv.notation);
            xml.push_str(&format!("    <move>{}</move>\n", escaped_notation));
        }
        xml.push_str("  </moves>\n");
    }

    // Result
    xml.push_str(&format!(
        "  <result>{}</result>\n",
        game.result.to_pgn_string()
    ));

    xml.push_str("</pgn>");
    xml
}

/// Convert an XML string to a PgnGame (simplified parser)
///
/// This is a basic XML parser that handles the specific format
/// generated by pgn_to_xml(). It does not handle general XML parsing.
///
/// # Examples
/// ```
/// use cn_chess_tui::pgn::{PgnGame, PgnGameResult};
/// use cn_chess_tui::xml::{pgn_to_xml, xml_to_pgn};
///
/// let mut game = PgnGame::new();
/// game.set_tag("Event", "Test Game");
/// game.set_tag("Red", "Player1");
/// game.add_move("h2e2");
/// game.add_move("h9g7");
/// game.result = PgnGameResult::RedWins;
///
/// let xml = pgn_to_xml(&game);
/// let parsed_game = xml_to_pgn(&xml).unwrap();
///
/// assert_eq!(parsed_game.get_tag("Event"), game.get_tag("Event"));
/// assert_eq!(parsed_game.get_tag("Red"), game.get_tag("Red"));
/// assert_eq!(parsed_game.moves.len(), game.moves.len());
/// ```
pub fn xml_to_pgn(xml: &str) -> Option<PgnGame> {
    let mut game = PgnGame::new();
    let mut in_tags = false;
    let mut in_moves = false;
    let mut in_result = false;
    let mut current_tag_name = String::new();
    let mut current_content = String::new();
    let mut chars = xml.chars().peekable();

    while let Some(c) = chars.next() {
        match c {
            '<' => {
                // Check for closing tag or opening tag
                if let Some(&next) = chars.peek() {
                    if next == '/' {
                        // Closing tag
                        chars.next(); // Consume '/'
                        let tag_name = read_tag_name(&mut chars)?;

                        match tag_name.as_str() {
                            "tags" => in_tags = false,
                            "moves" => in_moves = false,
                            "result" => {
                                game.result = PgnGameResult::parse(current_content.trim())
                                    .unwrap_or(PgnGameResult::Unknown);
                                in_result = false;
                            }
                            "pgn" => break, // End of document
                            _ => {
                                // It's a closing tag for a specific tag or move
                                if in_moves && tag_name == "move" {
                                    game.add_move(unescape_xml(current_content.trim()));
                                } else if in_tags && !current_tag_name.is_empty() {
                                    game.set_tag(
                                        current_tag_name.clone(),
                                        unescape_xml(&current_content),
                                    );
                                }
                            }
                        }

                        current_tag_name.clear();
                        current_content.clear();
                    } else if next == '!' {
                        // Comment or declaration, skip to next '>'
                        while let Some(&ch) = chars.peek() {
                            chars.next();
                            if ch == '>' {
                                break;
                            }
                        }
                    } else if next == '?' {
                        // XML declaration, skip to next '?>'
                        chars.next(); // Consume '?'
                        while let Some(&ch) = chars.peek() {
                            chars.next();
                            if ch == '?' {
                                if let Some(&'>') = chars.peek() {
                                    chars.next();
                                    break;
                                }
                            }
                        }
                    } else {
                        // Opening tag
                        let tag_name = read_tag_name(&mut chars)?;

                        match tag_name.as_str() {
                            "tags" => in_tags = true,
                            "moves" => in_moves = true,
                            "move" => {
                                current_content.clear();
                            }
                            "result" => {
                                current_content.clear();
                                in_result = true;
                            }
                            _ => {
                                if in_tags {
                                    current_tag_name = tag_name;
                                    current_content.clear();
                                }
                            }
                        }

                        // Skip to closing '>'
                        while let Some(&ch) = chars.peek() {
                            chars.next();
                            if ch == '>' {
                                break;
                            }
                        }
                    }
                }
            }
            _ => {
                // Content character
                if in_tags && !current_tag_name.is_empty() || in_moves || in_result {
                    current_content.push(c);
                }
            }
        }
    }

    Some(game)
}

/// Helper function to read a tag name from XML
fn read_tag_name(chars: &mut std::iter::Peekable<std::str::Chars>) -> Option<String> {
    let mut name = String::new();

    while let Some(&c) = chars.peek() {
        if c.is_whitespace() || c == '>' || c == '/' {
            break;
        }
        name.push(c);
        chars.next();
    }

    Some(name)
}

/// Save content to a file
///
/// # Examples
/// ```no_run
/// use cn_chess_tui::xml::save_content;
///
/// let content = "Hello, World!";
/// save_content("test.txt", content).unwrap();
/// ```
pub fn save_content(path: &str, content: &str) -> std::io::Result<()> {
    let mut file = File::create(path)?;
    file.write_all(content.as_bytes())?;
    Ok(())
}

#[cfg(test)]
mod tests {
    use super::*;

    #[test]
    fn test_escape_xml_basic() {
        assert_eq!(escape_xml("a < b"), "a &lt; b");
        assert_eq!(escape_xml("a > b"), "a &gt; b");
        assert_eq!(escape_xml("a & b"), "a &amp; b");
        assert_eq!(escape_xml("\"hello\""), "&quot;hello&quot;");
        assert_eq!(escape_xml("'world'"), "&apos;world&apos;");
    }

    #[test]
    fn test_escape_xml_combined() {
        assert_eq!(
            escape_xml("if (a < b && c > d)"),
            "if (a &lt; b &amp;&amp; c &gt; d)"
        );
    }

    #[test]
    fn test_escape_xml_empty() {
        assert_eq!(escape_xml(""), "");
    }

    #[test]
    fn test_unescape_xml_basic() {
        assert_eq!(unescape_xml("a &lt; b"), "a < b");
        assert_eq!(unescape_xml("a &gt; b"), "a > b");
        assert_eq!(unescape_xml("a &amp; b"), "a & b");
        assert_eq!(unescape_xml("&quot;hello&quot;"), "\"hello\"");
        assert_eq!(unescape_xml("&apos;world&apos;"), "'world'");
    }

    #[test]
    fn test_unescape_xml_combined() {
        assert_eq!(
            unescape_xml("if (a &lt; b &amp;&amp; c &gt; d)"),
            "if (a < b && c > d)"
        );
    }

    #[test]
    fn test_escape_unescape_roundtrip() {
        let original = "if (a < b && c > d) { return \"test\"; }";
        let escaped = escape_xml(original);
        let unescaped = unescape_xml(&escaped);
        assert_eq!(original, unescaped);
    }

    #[test]
    fn test_pgn_to_xml_simple() {
        let mut game = PgnGame::new();
        game.set_tag("Event", "Test Game");
        game.set_tag("Red", "Player1");
        game.add_move("h2e2");
        game.add_move("h9g7");
        game.result = PgnGameResult::RedWins;

        let xml = pgn_to_xml(&game);

        assert!(xml.contains("<?xml version=\"1.0\" encoding=\"UTF-8\"?>"));
        assert!(xml.contains("<pgn>"));
        assert!(xml.contains("<Event>Test Game</Event>"));
        assert!(xml.contains("<Red>Player1</Red>"));
        assert!(xml.contains("<move>h2e2</move>"));
        assert!(xml.contains("<move>h9g7</move>"));
        assert!(xml.contains("<result>1-0</result>"));
        assert!(xml.contains("</pgn>"));
    }

    #[test]
    fn test_pgn_to_xml_with_special_chars() {
        let mut game = PgnGame::new();
        game.set_tag("Event", "Tom & Jerry <Championship>");
        game.set_tag("Site", "\"Beijing\"");
        game.add_move("h2e2");
        game.result = PgnGameResult::RedWins;

        let xml = pgn_to_xml(&game);

        // Check that special characters are escaped
        assert!(xml.contains("&amp;"));
        assert!(xml.contains("&lt;"));
        assert!(xml.contains("&gt;"));
        assert!(xml.contains("&quot;"));
    }

    #[test]
    fn test_pgn_to_xml_empty_game() {
        let game = PgnGame::new();
        let xml = pgn_to_xml(&game);

        assert!(xml.contains("<pgn>"));
        assert!(xml.contains("<tags>"));
        assert!(xml.contains("</tags>"));
        assert!(!xml.contains("<moves>")); // No moves section
        assert!(xml.contains("<result>*</result>"));
    }

    #[test]
    fn test_xml_to_pgn_simple() {
        let xml = r#"<?xml version="1.0" encoding="UTF-8"?>
<pgn>
  <tags>
    <Event>Test Game</Event>
    <Red>Player1</Red>
    <Black>Player2</Black>
  </tags>
  <moves>
    <move>h2e2</move>
    <move>h9g7</move>
  </moves>
  <result>1-0</result>
</pgn>"#;

        let game = xml_to_pgn(xml).unwrap();

        assert_eq!(game.get_tag("Event"), Some(&"Test Game".to_string()));
        assert_eq!(game.get_tag("Red"), Some(&"Player1".to_string()));
        assert_eq!(game.get_tag("Black"), Some(&"Player2".to_string()));
        assert_eq!(game.moves.len(), 2);
        assert_eq!(game.moves[0].notation, "h2e2");
        assert_eq!(game.moves[1].notation, "h9g7");
        assert_eq!(game.result, PgnGameResult::RedWins);
    }

    #[test]
    fn test_xml_to_pgn_with_escaped_chars() {
        let xml = r#"<?xml version="1.0" encoding="UTF-8"?>
<pgn>
  <tags>
    <Event>Tom &amp; Jerry</Event>
    <Site>&quot;Beijing&quot;</Site>
  </tags>
  <result>*</result>
</pgn>"#;

        let game = xml_to_pgn(xml).unwrap();

        assert_eq!(game.get_tag("Event"), Some(&"Tom & Jerry".to_string()));
        assert_eq!(game.get_tag("Site"), Some(&"\"Beijing\"".to_string()));
    }

    #[test]
    fn test_xml_to_pgn_no_moves() {
        let xml = r#"<?xml version="1.0" encoding="UTF-8"?>
<pgn>
  <tags>
    <Event>Test</Event>
  </tags>
  <result>*</result>
</pgn>"#;

        let game = xml_to_pgn(xml).unwrap();

        assert_eq!(game.get_tag("Event"), Some(&"Test".to_string()));
        assert_eq!(game.moves.len(), 0);
    }

    #[test]
    fn test_pgn_xml_roundtrip() {
        let mut original = PgnGame::new();
        original.set_tag("Event", "World Championship");
        original.set_tag("Red", "Hu Ronghua");
        original.set_tag("Black", "Liu Dahua");
        original.add_move("h2e2");
        original.add_move("h9g7");
        original.add_move("h3g3");
        original.result = PgnGameResult::RedWins;

        let xml = pgn_to_xml(&original);
        let parsed = xml_to_pgn(&xml).unwrap();

        assert_eq!(original.tags.len(), parsed.tags.len());
        for tag in &original.tags {
            assert_eq!(parsed.get_tag(&tag.key), Some(&tag.value));
        }
        assert_eq!(original.moves.len(), parsed.moves.len());
        assert_eq!(original.result, parsed.result);
    }

    #[test]
    fn test_save_content() {
        use std::fs;
        use std::path::Path;

        let test_path = "/tmp/test_xml_save.txt";
        let content = "Hello, XML!";

        save_content(test_path, content).unwrap();

        assert!(Path::new(test_path).exists());
        let read_content = fs::read_to_string(test_path).unwrap();
        assert_eq!(read_content, content);

        // Cleanup
        fs::remove_file(test_path).ok();
    }

    #[test]
    fn test_xml_to_pgn_all_results() {
        let results = vec![
            ("1-0", PgnGameResult::RedWins),
            ("0-1", PgnGameResult::BlackWins),
            ("1/2-1/2", PgnGameResult::Draw),
            ("*", PgnGameResult::Unknown),
        ];

        for (result_str, expected_result) in results {
            let xml = format!(
                r#"<?xml version="1.0" encoding="UTF-8"?>
<pgn>
  <tags>
    <Event>Test</Event>
  </tags>
  <result>{}</result>
</pgn>"#,
                result_str
            );

            let game = xml_to_pgn(&xml).unwrap();
            assert_eq!(game.result, expected_result);
        }
    }

    #[test]
    fn test_xml_to_pgn_multiple_moves() {
        let xml = r#"<?xml version="1.0" encoding="UTF-8"?>
<pgn>
  <tags>
    <Event>Test</Event>
  </tags>
  <moves>
    <move>h2e2</move>
    <move>h9g7</move>
    <move>h3g3</move>
    <move>i9h9</move>
    <move>b0c2</move>
    <move>b9a7</move>
  </moves>
  <result>*</result>
</pgn>"#;

        let game = xml_to_pgn(xml).unwrap();

        assert_eq!(game.moves.len(), 6);
        assert_eq!(game.moves[0].notation, "h2e2");
        assert_eq!(game.moves[5].notation, "b9a7");
    }
}
